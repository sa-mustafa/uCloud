/*
 * uCloud API collection
 *
 * uCloud is a collection of image APIs.
 *
 * OpenAPI spec version: 1.0.2
 * Contact: help@bps-eng.co.ir
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace Bps.uCloud.API.Models
{
    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class Matcher : IEquatable<Matcher>
    {
        /// <summary>
        /// Gets or sets unique id or name
        /// </summary>
        [Required]
        [DataMember(Name = "name")]
        public string Name { get; set; }

        /// <summary>
        /// Specify the matcher type to use: * NCC: normalized cross correlation matching * Anisotropic: shape model with orientation change and independent scaling in column & row directions * Isotropic: shape model with orientation change and equal scaling in column & row directions * Shape: shape model matching with orientation change only * Deformable: deformable shape model with orientation change and independent scaling in column & row directions * Feature: interest point matching for objects distorted by a projective view * Perspective: deformable model matching for objects distorted by a projective view 
        /// </summary>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum TypeEnum
        {
            /// <summary>
            /// Enum NCCEnum for NCC
            /// </summary>
            [EnumMember(Value = "NCC")]
            NCCEnum = 1,

            /// <summary>
            /// Enum AnisotropicEnum for Anisotropic
            /// </summary>
            [EnumMember(Value = "Anisotropic")]
            AnisotropicEnum = 2,

            /// <summary>
            /// Enum IsotropicEnum for Isotropic
            /// </summary>
            [EnumMember(Value = "Isotropic")]
            IsotropicEnum = 3,

            /// <summary>
            /// Enum ShapeEnum for Shape
            /// </summary>
            [EnumMember(Value = "Shape")]
            ShapeEnum = 4,

            /// <summary>
            /// Enum DeformableEnum for Deformable
            /// </summary>
            [EnumMember(Value = "Deformable")]
            DeformableEnum = 5,

            /// <summary>
            /// Enum FeatureEnum for Feature
            /// </summary>
            [EnumMember(Value = "Feature")]
            FeatureEnum = 6,

            /// <summary>
            /// Enum PerspectiveEnum for Perspective
            /// </summary>
            [EnumMember(Value = "Perspective")]
            PerspectiveEnum = 7
        }

        /// <summary>
        /// Specify the matcher type to use: * NCC: normalized cross correlation matching * Anisotropic: shape model with orientation change and independent scaling in column &amp; row directions * Isotropic: shape model with orientation change and equal scaling in column &amp; row directions * Shape: shape model matching with orientation change only * Deformable: deformable shape model with orientation change and independent scaling in column &amp; row directions * Feature: interest point matching for objects distorted by a projective view * Perspective: deformable model matching for objects distorted by a projective view 
        /// </summary>
        [Required]
        [DataMember(Name = "type")]
        public TypeEnum? Type { get; set; }

        /// <summary>
        /// smallest rotation of the pattern in degrees; applies to all matchers except feature type
        /// </summary>
        [DataMember(Name = "angle_start")]
        public float? AngleStart { get; set; }

        /// <summary>
        /// extent of the rotation angle in degrees; applies to all matchers except feature type
        /// </summary>
        [DataMember(Name = "angle_extent")]
        public float? AngleExtent { get; set; }

        /// <summary>
        /// step length of the angles in degrees; applies to all matchers except feature type
        /// </summary>
        [DataMember(Name = "angle_step")]
        public float? AngleStep { get; set; }

        /// <summary>
        /// Specify the model contrast in the template image; 3 values may be specified: lower threshold, upper threshold and minimum object size for suppressing small artifacts; applies to all matchers except NCC/feature types.
        /// </summary>
        [DataMember(Name = "contrast")]
        public List<float?> Contrast { get; set; }

        /// <summary>
        /// Specify the minimum object contrast in the search image; this value should be chosen larger the noise level in the image; applies to all matchers except NCC/feature types.
        /// </summary>
        [DataMember(Name = "min_contrast")]
        public float? MinContrast { get; set; }

        /// <summary>
        /// select feature type; applies only to feature matcher type.
        /// </summary>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum FeatureTypeEnum
        {

            /// <summary>
            /// Enum LepetitEnum for lepetit
            /// </summary>
            [EnumMember(Value = "lepetit")]
            LepetitEnum = 1,

            /// <summary>
            /// Enum HarrisEnum for harris
            /// </summary>
            [EnumMember(Value = "harris")]
            HarrisEnum = 2,

            /// <summary>
            /// Enum HarrisBinomialEnum for harris_binomial
            /// </summary>
            [EnumMember(Value = "harris_binomial")]
            HarrisBinomialEnum = 3
        }

        /// <summary>
        /// select feature type; applies only to feature matcher type.
        /// </summary>
        [DataMember(Name = "feature_type")]
        public FeatureTypeEnum? FeatureType { get; set; }

        /// <summary>
        /// Gets or Sets FeatureOptions
        /// </summary>
        [DataMember(Name = "feature_options")]
        public MatcherFeatureOptions FeatureOptions { get; set; }

        /// <summary>
        /// choose optimization applied to model generation; applies to all matchers except NCC/feature types.
        /// </summary>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum OptimizationEnum
        {

            /// <summary>
            /// Enum AutoEnum for auto
            /// </summary>
            [EnumMember(Value = "auto")]
            AutoEnum = 1,

            /// <summary>
            /// Enum NoneEnum for none
            /// </summary>
            [EnumMember(Value = "none")]
            NoneEnum = 2,

            /// <summary>
            /// Enum LowEnum for low
            /// </summary>
            [EnumMember(Value = "low")]
            LowEnum = 3,

            /// <summary>
            /// Enum MediumEnum for medium
            /// </summary>
            [EnumMember(Value = "medium")]
            MediumEnum = 4,

            /// <summary>
            /// Enum HighEnum for high
            /// </summary>
            [EnumMember(Value = "high")]
            HighEnum = 5
        }

        /// <summary>
        /// choose optimization applied to model generation; applies to all matchers except NCC/feature types.
        /// </summary>
        [DataMember(Name = "optimization")]
        public OptimizationEnum? Optimization { get; set; }

        /// <summary>
        /// maximum number of pyramid levels; applies to all matchers except feature type
        /// </summary>
        [DataMember(Name = "pyramids")]
        public int? Pyramids { get; set; }

        /// <summary>
        /// Specify whether to enforce the model polarity; applies to all matchers except feature type. * enforce: match the object accrdoing to initial model's contrast level * ignore_color: matching should ignore changes in the object color; it is not applicable to NCC type * ignore_local: matching should ignore changes in the object contrast; it is not applicable to NCC type * ignore_global: match the object even if the whole image contrast is inverted.  
        /// </summary>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum PolarityEnum
        {

            /// <summary>
            /// Enum EnforceEnum for enforce
            /// </summary>
            [EnumMember(Value = "enforce")]
            EnforceEnum = 1,

            /// <summary>
            /// Enum IgnoreColorEnum for ignore_color
            /// </summary>
            [EnumMember(Value = "ignore_color")]
            IgnoreColorEnum = 2,

            /// <summary>
            /// Enum IgnoreLocalEnum for ignore_local
            /// </summary>
            [EnumMember(Value = "ignore_local")]
            IgnoreLocalEnum = 3,

            /// <summary>
            /// Enum IgnoreGlobalEnum for ignore_global
            /// </summary>
            [EnumMember(Value = "ignore_global")]
            IgnoreGlobalEnum = 4
        }

        /// <summary>
        /// Specify whether to enforce the model polarity; applies to all matchers except feature type. * enforce: match the object accrdoing to initial model's contrast level * ignore_color: matching should ignore changes in the object color; it is not applicable to NCC type * ignore_local: matching should ignore changes in the object contrast; it is not applicable to NCC type * ignore_global: match the object even if the whole image contrast is inverted.  
        /// </summary>
        [DataMember(Name = "polarity")]
        public PolarityEnum? Polarity { get; set; }

        /// <summary>
        /// Specify the model scale variation in column(X) direction; 3 values may be specified: minimum scale, maximum scale and scale step change for model creation; applies to anisotropic/deformable/perspective types.
        /// </summary>
        [DataMember(Name = "scale_col")]
        public List<float?> ScaleCol { get; set; }

        /// <summary>
        /// Specify the model scale variation in row(Y) direction; 3 values may be specified: minimum scale, maximum scale and scale step change for model creation; applies to anisotropic/deformable/perspective types.
        /// </summary>
        [DataMember(Name = "scale_row")]
        public List<float?> ScaleRow { get; set; }

        /// <summary>
        /// Specify the model scale variation in; 3 values may be specified: minimum scale, maximum scale and scale step change for model creation; applies to isotropic type only.
        /// </summary>
        [DataMember(Name = "scale")]
        public List<float?> Scale { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Matcher {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  AngleStart: ").Append(AngleStart).Append("\n");
            sb.Append("  AngleExtent: ").Append(AngleExtent).Append("\n");
            sb.Append("  AngleStep: ").Append(AngleStep).Append("\n");
            sb.Append("  Contrast: ").Append(Contrast).Append("\n");
            sb.Append("  MinContrast: ").Append(MinContrast).Append("\n");
            sb.Append("  FeatureType: ").Append(FeatureType).Append("\n");
            sb.Append("  FeatureOptions: ").Append(FeatureOptions).Append("\n");
            sb.Append("  Optimization: ").Append(Optimization).Append("\n");
            sb.Append("  Pyramids: ").Append(Pyramids).Append("\n");
            sb.Append("  Polarity: ").Append(Polarity).Append("\n");
            sb.Append("  ScaleCol: ").Append(ScaleCol).Append("\n");
            sb.Append("  ScaleRow: ").Append(ScaleRow).Append("\n");
            sb.Append("  Scale: ").Append(Scale).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((Matcher)obj);
        }

        /// <summary>
        /// Returns true if Matcher instances are equal
        /// </summary>
        /// <param name="other">Instance of Matcher to be compared</param>
        public bool Equals(Matcher other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) &&
                (
                    Type == other.Type ||
                    Type != null &&
                    Type.Equals(other.Type)
                ) &&
                (
                    AngleStart == other.AngleStart ||
                    AngleStart != null &&
                    AngleStart.Equals(other.AngleStart)
                ) &&
                (
                    AngleExtent == other.AngleExtent ||
                    AngleExtent != null &&
                    AngleExtent.Equals(other.AngleExtent)
                ) &&
                (
                    AngleStep == other.AngleStep ||
                    AngleStep != null &&
                    AngleStep.Equals(other.AngleStep)
                ) &&
                (
                    Contrast == other.Contrast ||
                    Contrast != null &&
                    Contrast.SequenceEqual(other.Contrast)
                ) &&
                (
                    MinContrast == other.MinContrast ||
                    MinContrast != null &&
                    MinContrast.Equals(other.MinContrast)
                ) &&
                (
                    FeatureType == other.FeatureType ||
                    FeatureType != null &&
                    FeatureType.Equals(other.FeatureType)
                ) &&
                (
                    FeatureOptions == other.FeatureOptions ||
                    FeatureOptions != null &&
                    FeatureOptions.Equals(other.FeatureOptions)
                ) &&
                (
                    Optimization == other.Optimization ||
                    Optimization != null &&
                    Optimization.Equals(other.Optimization)
                ) &&
                (
                    Pyramids == other.Pyramids ||
                    Pyramids != null &&
                    Pyramids.Equals(other.Pyramids)
                ) &&
                (
                    Polarity == other.Polarity ||
                    Polarity != null &&
                    Polarity.Equals(other.Polarity)
                ) &&
                (
                    ScaleCol == other.ScaleCol ||
                    ScaleCol != null &&
                    ScaleCol.SequenceEqual(other.ScaleCol)
                ) &&
                (
                    ScaleRow == other.ScaleRow ||
                    ScaleRow != null &&
                    ScaleRow.SequenceEqual(other.ScaleRow)
                ) &&
                (
                    Scale == other.Scale ||
                    Scale != null &&
                    Scale.SequenceEqual(other.Scale)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                if (Type != null)
                    hashCode = hashCode * 59 + Type.GetHashCode();
                if (AngleStart != null)
                    hashCode = hashCode * 59 + AngleStart.GetHashCode();
                if (AngleExtent != null)
                    hashCode = hashCode * 59 + AngleExtent.GetHashCode();
                if (AngleStep != null)
                    hashCode = hashCode * 59 + AngleStep.GetHashCode();
                if (Contrast != null)
                    hashCode = hashCode * 59 + Contrast.GetHashCode();
                if (MinContrast != null)
                    hashCode = hashCode * 59 + MinContrast.GetHashCode();
                if (FeatureType != null)
                    hashCode = hashCode * 59 + FeatureType.GetHashCode();
                if (FeatureOptions != null)
                    hashCode = hashCode * 59 + FeatureOptions.GetHashCode();
                if (Optimization != null)
                    hashCode = hashCode * 59 + Optimization.GetHashCode();
                if (Pyramids != null)
                    hashCode = hashCode * 59 + Pyramids.GetHashCode();
                if (Polarity != null)
                    hashCode = hashCode * 59 + Polarity.GetHashCode();
                if (ScaleCol != null)
                    hashCode = hashCode * 59 + ScaleCol.GetHashCode();
                if (ScaleRow != null)
                    hashCode = hashCode * 59 + ScaleRow.GetHashCode();
                if (Scale != null)
                    hashCode = hashCode * 59 + Scale.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(Matcher left, Matcher right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(Matcher left, Matcher right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}